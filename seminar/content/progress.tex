\section{Work So Far}

\begin{frame}{Work So Far}
	Thus far, most of the work on my thesis has been split between three tasks:
	
	\begin{enumerate}
		\item Familiarising with one particular implementation: JIF (Java Information Flow)
		\item Researching information flow models and implementations
		\item Researching the applicability of information flow to real security problems
	\end{enumerate}
\end{frame}

\begin{frame}{JIF}
	Java Information Flow is a language extension to Java with `mostly static' information flow features through `security types', which are policies as per the Decentralised Label Model \cite{work:myersdlm}.
	
	Every variable has a security label attached to it which encodes how its information may flow between principals. For instance:
	
	\texttt{int\{Alice->Bob\} x;}
	
	indicates that principal Alice owns the information, and allows that information to flow to Bob or a principal Bob has delegated authority to.
\end{frame}

\begin{frame}{JIF: Static Checking Errors}
	\begin{figure}
		\includegraphics[scale=0.5]{content/images/jif_helloworld_error.png}
		\caption{A JIF compiler error}
	\end{figure}
\end{frame}

\begin{frame}{JIF: A Minimal `Hello World'}
	\begin{figure}
		\includegraphics[width=\linewidth]{content/images/jif_helloworld.png}
	\end{figure}
\end{frame}

\begin{frame}{JIF: Practicality \& Programmer Burden}
	As a language which is not widely used, documentation and examples for JIF are sparse. The language also does not have a debugger, and the static checking error messages often fail to explain the true source of an issue.
	
	Even aside from those implementational issues, JIF inherently places a large burden on the programmer: the programmer must correctly keep track of information flows and provide the correct policies each time they are used (though type inference helps).
\end{frame}

\begin{frame}{Other Implementations}
	\begin{enumerate}
		\item Paragon
		\item LIFTy
		\item Dynamic ones
	\end{enumerate}
\end{frame}

\begin{frame}{General Applicability}
	Oracle Guidelines
	
	Untrusted code vs Untrusted data
	
	Actual exploits
\end{frame}

\begin{frame}{Overall Thoughts}
	`Heavy' programmer burden
	
	Not relevant for most security issues
	
	Potential for `lighter' solutions (e.g. LIFTy, static analysis tools)
\end{frame}