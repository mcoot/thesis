\section{Background}

\begin{frame}{Information Flow and Access Control}
	Many systems control access to information with \textbf{access control} mechanisms, which place restrictions based on the \textit{permissions} of a user or of calling code but which cannot restrict how that information \textit{propagates} once released \cite{ifbackground:sabelfeld}.
	
	\textbf{Information flow} mechanisms instead control access by enforcing that some \textit{policy} on the data is upheld.
	
	In short, access control puts controls on the \textit{calling code}, where information flow puts controls on the \textit{data}.
\end{frame}

\begin{frame}{Information Flow Basics}
	In its most general form, information flow security considers confidentiality states. An information flow policy formalises how information may move between states.
	
	This is commonly represented by applying the Bell-LaPadula Lattice model used in Mandatory Access Control.
	
	\begin{figure}
		\includegraphics[scale=0.45]{content/images/lattice_examples.png}
		\caption{Example Lattice Model policies \cite{ifbackground:sandhu}}
	\end{figure}
	
\end{frame}

\begin{frame}{Noninterference}
	\begin{block}{Noninterference}
		``A group of users [or a program] is noninterfering with another group of users if what the first group does with those commands has no effect on what the second group of users can see."\newline \tiny{-- Goguen \& Meseguer} \cite{ifbackground:goguen}
	\end{block}
	
	Information flow models attempt to verify that programs have the property of \textit{noninterference}. A noninterfering program \textit{provably} protects confidentiality by guaranteeing that disallowed flows can never occur.
\end{frame}

\begin{frame}{Noninterference - Is It Practical?}
	There are two serious problems with proving noninterference:
	
	\begin{enumerate}
		\item Proving non-interference (in the general case) is undecidable
			\begin{itemize}
				\item The halting problem can be reduced to it -- consider: \newline \texttt{\textbf{if} S() halts \textbf{then} h := 1 \textbf{else} h := 0} \cite{ifbackground:denninghalting}
			\end{itemize}
		\item Many useful programs are inherently interfering
			\begin{itemize}
				\item A password checker's output clearly depends on the password
			\end{itemize}
	\end{enumerate}
	
	Instead, most information flow solutions allow for data to be `selectively declassified'.
\end{frame}

\begin{frame}{Enforcement: Static or Dynamic?}
	Controls be enforced at compile-time or at run-time.
	
	\textbf{Static} information flow controls produce no run-time overhead, and can much more easily track `implicit flows'.
	
	\textbf{Dynamic} information flow controls include some overhead and cannot track implicit flows, but can be more flexible and can represent a wider range of policies.
	
	Most solutions use static or `mostly static' approaches.
\end{frame}

\begin{frame}{Information Flow and Integrity}
	Information flow is usually talked about with respect to Confidentiality, but it can also be applied to the problem of Integrity.
	
	Rather than tracking the flow of high confidentiality (i.e. `secret') outputs, you instead track the flow of low integrity (i.e. `tainted') inputs.
\end{frame}