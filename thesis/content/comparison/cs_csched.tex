\section{Case Study 3: Calendar Scheduler}

%\textbf{Explanation}
%
%Users have calendars, which in turn have meetings. Meetings have a beginning and start time, a title and a list of attending users (users must attend meetings on their calendars).
%
%The application has multiple users, and allows users to schedule a time for a new meeting when all users are free. Hence, the times of meetings are not confidential. The titles however are restricted to be visible only to attendees of that meeting.
%
%\textbf{Security properties:}
%
%Some properties of each meeting are confidential but not others.
%
%The confidentiality of meetings is bound to their list of attendees (i.e. quantified over some list)
%
%\textbf{Key points:}
%
%Both Paragon and JIF cannot encode the required policies.
%
%JIF fails entirely since lists are a dynamic construct and JIF cannot handle dynamic policies.
%
%Paragon's policy language can encode the idea of the dynamic construct but annotations don't allow universal quantification -- hence the language can express the idea of a singular `owner' of a meeting, but not a list of attendees.
%
%Paragon's compiler cannot however statically determine that different instances are different actors in this case, even in the single owner example.
%
%JIF and Paragon can express the `owner' policy in a way that will (to some degree) work, but it relies on using principals/actors as type parameters.
%
%\textbf{Toy examples:}
%
%Demonstration of failure to determine actors (Paragon)
%
%Simple example where quantification is required
%
%\newpage

\subsection{Overview}

The final case study is an implementation of a multi-user `calendar scheduler' application. The application has multiple users, each with their own calendar. A calendar consists of a list of meetings; each meeting has a title, and is associated with a day of the week and starting and finishing time. In addition, each meeting has a list of users who are attending the meeting.

The application allows users to schedule new meetings so as to avoid conflicting with existing meetings. Each meeting's details are secret -- only the attendees may know the title of the meeting. However, the times of the meetings need to be available to all users in order to schedule new meetings.

\subsection{Key Security Properties}

On the surface the security property here may seem to lack complexity. As with the second case study there is a data structure in the form of a meeting which contains some high confidentiality data (the title) and some low confidentiality data (the time). Unlike that case, the data is not time-variant but instead dependent on the involvement of particular users -- which seems like a natural fit for the principals of JIF.

However, there are two key differences that distinguish this policy from those discussed previously:

\begin{enumerate}
	
	\item Rather than being `owned' by a single actor or principal, a meeting is essentially confidential to a \textit{set} of principals
	
	\item It is required that meetings be able to be created at runtime with any possible attendees, so the policy model must be able to reason about the restrictions on such dynamically created meetings
	
\end{enumerate}

\subsection{Implementation Structure}

Both calendar scheduler implementations follow the following class structure:

\begin{itemize}
	
	\item \mono{User}: a simple immutable user with a name
	
	\begin{itemize}
		\item Polymorphic with respect to security policy
	\end{itemize}

	\item \mono{Meeting}: a single immutable meeting with a time, a title and a list of attendees
	
	\begin{itemize}
		\item The time information about the meeting is low confidentiality
		
		\item The title is secret and is accessible only to attendees of the meeting
	\end{itemize}

	\item \mono{Calendar}: a calendar of scheduled meetings belonging to a user

	\begin{itemize}
		\item The user must attend all meetings on their calendar
		
		\item Since attendance of meetings on a user's calendar may vary, other users may be able to access different portions of a given user's calendar
	\end{itemize}
	
	\item \mono{Scheduler}: keeps a calendar for each user in the system, and allows for checking whether a given time slot conflicts with existing meetings for some set of users
	
	\item \mono{Main}: contains a main method to set up dummy data and run the scheduler
	
	
\end{itemize}

\subsection{Simplification of Implementation}

The implementation described above, with the use of confidentiality states which depend on sets of users, is not practical to implement in either JIF or Paragon: quantification over a set of principals is not possible in the policy languages of either. The specific issues encountered in each language is described in the below section, but in both cases this quantification problem effectively prevents implementation from proceeding in practice.

As a result, the actual implementations instead work around a simplified security policy, where each meeting is designated a single \textit{owner} principal who controls its confidentiality. This does not quite produce the desired application (since it unnecessarily restricts access to the title beyond what is required), but even so this simplified implementation also runs up against language and compiler limitations in both Paragon and JIF.

\subsection{JIF Implementation}

\subsubsection{`Sets' of Users}

The desired confidentiality property, where a meeting's title is visible to its attendees, is difficult to encode in a purely static-checked manner, regardless of the policy model used, since the set of attendees of a meeting is a runtime value. In JIF's case, there is no model for expressing the concept of an arbitrary set of principals through the type system: a class may be parametrised by \textit{one} principal, but not a set of them.

Since this quantification over sets of principals cannot be encoded within JIF, the implementation proceeded as per the simplified policy above.

\subsubsection{`Ownership' Policy Structure}

Restricting the confidentiality policy to a single meeting owner rather than a list of attendees made implementation more practicable. Under this model, the \mono{Meeting} class must be associated with an `owner' principal. This may be achieved in JIF either through a principal type parameter. Hence, the \mono{Meeting} data type has the policy \jiflabel{Owner->\_} on its low confidentiality data, and \jiflabel{Owner->*} on the high confidentiality title.

\subsubsection{Dynamic Users}

The initial design of the case study implementation has the \mono{User} class, each instance of which is associated with a user of the application. Unlike Paragon, JIF does not use object instances as actors, and so there is no connection in the type system between a \mono{User} instance and the principal it would represent.

This presents a challenge for development: for the application to make sense, it should not be hard-coded to some predefined list of principals. In JIF, this is not possible at the top level: principals are types (i.e. classes) and so it is not possible to dynamically create them at runtime without reflection (which JIF does not support).

This problem was encountered by researchers at Pennsylvania State University in developing the JPMail secure email client \cite{jpmailpage}. An email client should support multiple, arbitrary users and as a result a set of policy tools were built for JPMail, alongside the `JIFclipse' suite of tools \cite{hicks2007jifclipse}. However, this system requires extensions to the JIF language and runtime, and even with these, in practice JPMail cannot handle new users added `on the fly' -- it requires recompilation of certain components.

In practice, the JIF implementation for this case study attempts to make use of JIF's runtime \mono{Principal} class to work around the issue of dynamic principals. In practice however, this was not effective: the program could be written, but the compiler would not properly enforce information flow constraints on it.

\subsection{Paragon Implementation}

\subsubsection{Dealing with Sets of Users}

The quantification issue affects Paragon as it does JIF. Paragon's policy language uses objects as actors, and so it is able to get closer to modelling the concept. A binary lock \mono{isAttending(User, Meeting)} may be defined, where the lock is open for User \mono{u} and Meeting \mono{m} (i.e. \mono{isAttending(u, m)}) if \mono{u} is in the list of attendees of \mono{m}.

Since the list of attendees itself is a runtime value, this status cannot automatically be `linked' to the relation via a lock property: the lock must be opened manually for each attendee when the Meeting object is created. While the policy language allows this to be expressed, the Paragon compiler is not able to perform the necessary static analysis to enforce this, and hence when secret data is accessed (e.g. by printing out the Meeting via its \mono{toString} method), the compiler cannot tell whether the lock is in fact open, causing compile-time errors.

Paragon has two methods for getting around this, corresponding to the two mechanisms demonstrated in the Conference Management example: either method annotations can be used to restrict where the method may be called, or a run-time check can be used to provide a code context in which the lock is known to be open.

The former option cannot be applied to this case, because while it is possible to require a lock to be open (through something of the form \mono{\textasciitilde someLock}), for a binary lock one cannot quantify over the lock's parameters. That is, to express this policy an annotation would have to encode the concept ``\mono{isAttending(u, m)} must be open for the current instance \mono{m}, \textit{for all} users \mono{u} such that \mono{u} $ \in $ \mono{attendees}."

The latter method can be expressed by a runtime check in a for loop, and will produce compiling code. However, this approach was also abandoned in implementation because while the policy language allows for it, the Paragon compiler failed to then use this information correctly: it would actually \textit{violate} the required policy and allow a non-attendee to print out the secret information.

% map / singleton

\subsubsection{Ownership model issues}

The final implementation uses the simplified `owner policy', since this is more easily expressed in Paragon's model. As with JIF, a type parameter-based implementation is possible. Unlike JIF, Paragon's policy language has explicit support for dynamic actors (since actors are simply object instances), and its extension of Java's generics allow for more flexibility, as well as generic methods, which JIF lacks entirely.

However, the Paragon implementation produced avoids parametrising meetings by their owner, instead opting to keep a reference to the owner instance via a final field. This concept requires the `objects as actors' model and hence has no clear mapping to JIF.

Functionally, this means that the binary lock \mono{isOwner(User, Meeting)} guards access to the confidential meeting title information. Since this will only be true for one user, the quantification issue does not arise. However, in practice, Paragon's compiler was still unable to correctly analyse this: runtime checks are still required since the compiler is unable to statically determine the correct user, and once these checks are added, the compiler incorrectly allows users other than the owner to print out information.

This appears to be a practical issue with the immaturity of the Paragon compiler: interpreting the verbose-mode output of the compiler indicates that the actor identifier being associated with the owners of each meeting is the same, where in fact at runtime these owners will be different instances.

\subsection{Conclusion}

This case study could not be implemented correctly and with the desired information flow safeguards in either Paragon or JIF.

JIF runs into a dead end in attempting to deal with dynamic principals. This seems to be a fatal flaw in any attempt to use JIF to model this problem. More complex policy model and policy store systems like those implemented in JifClipse \cite{hicks2007jifclipse} may provide a solution to some of these issues, but these are not under active development, and work only with older versions of JIF.

Paragon's policy model is able to represent the policy more easily, but still struggles with quantifying of the policy over a set of attendees. Ultimately, even with the simplified `owner model' policy, Paragon's compiler struggles to properly enforce the policy. A type parameter-based implementation would still face some of these issues, but may be worth investigating in a future project as a way around the Paragon compiler issues encountered.