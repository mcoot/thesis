\chapter{Conclusions \& Further Work}

\section{Information Flow}

Language-based information flow security has potential application in any program which enforces a confidentiality policy, and where programmer error has the potential to lead to accidental violation of a policy.

As this has been a topic of research for several decades, a number of security typing-based models have been developed. Each of these builds on those that came before and attempts to improve policy definition and enforcement. The model implemented by \citeauthor{denning1977certification} \cite{denning1977certification} allows for verification of programs under a standard MAC lattice. The Decentralized Label Model improves upon this by allowing policies with no central source of truth, and by framing policies in terms of interacting principals. The ParaLock model \cite{broberg2010paralocks} attempts to address the deficiencies of prior systems in defining dynamic policies in more sophisticated ways than straightforward declassification.

Using the tools these models provide it is possible to construct and enforce many useful security policies, from simpler systems which enforce a MAC lattice policy to those which require a dynamic `timed release' policy, and through the application of these techniques it is possible to mitigate the real-world risks of improperly enforced confidentiality policies which programs that interact with data in any meaningful way face.

\section{JIF \& Paragon}

The JIF and Paragon programming languages pair relatively mature implementations of security typed information flow control with the syntax and standard library of Java, one of the most widely used languages in existence. Both can provide powerful confidentiality guarantees through information flow checking which is primarily performed at compile time, avoiding the potential overhead of a runtime mechanism.

Both systems can be used to encode meaningful security policies. JIF's model allows for policies built around interacting principals and, crucially, does not require a central source of truth to determine what policy should be applied to information. Its declassification mechanism allows for a much larger class of programs, beyond those which are strictly non-interfering, to be written, with some level of control applied through the `authority' construct. 

Paragon's policy model is more general, and has a lower conceptual barrier as a result of basing itself upon the familiar constructs of predicate logic. Its use of Flow Locks and ParaLocks also allows for a wider range of dynamic flow policies than can be encoded using JIF's Decentralised Label Model.

\subsection{Case Studies}

The case studies presented in \autoref{chap_comparison} demonstrated both the application of the two languages and their limitations.

\subsubsection{Battleships}

The Battleships case study presented in \ref{sect_cs_battleships} requires modelling a `game board' containing information secret to one of the game's players. This information must not leak to the other player, except through a specific querying mechanism as part of the game's rules. This policy is easily encoded in JIF by representing each player as a principal, and using a declassifying method to handle queries. Paragon similarly encodes this; it does not require an explicit principal for each players, because Paragon uses `objects as actors' -- the player instance itself \textit{is} the principal. Paragon performs declassification using a simple flow lock, cleanly emulating the same declassification strategy as the JIF implementation.

\subsubsection{Conference Management}

The Conference Management case study presented in \ref{sect_cs_conf} models a `timed release' policy, where the confidentiality status of session allocations for a paper submitted to a conference changes during the system's operation. Until the conference gives notification, the status is secret such that authors cannot learn whether their paper was accepted; after the notification the status is public information.

JIF's Decentralised Label Model cannot naturally encode this policy; timed release cannot be expressed in terms of interacting principals. As a result, the JIF implementation of this case study relies on using declassification as an `escape hatch' from the security typing system. Hence, developing this application in JIF is feasible, but doing so requires giving up some of the confidentiality guarantees that security typing provides.

Paragon, by contrast, encodes this policy with a single flow lock, which is opened when the timed release condition is met. Hence, the Paragon implementation of this application is able to provide more stringent confidentiality guarantees than the JIF version.

\subsubsection{Calendar Scheduler}

The Calendar Scheduler case study presented in \ref{sect_cs_csched} models a policy where the confidentiality of a meeting's details depend on the runtime list of attendees. Here, neither JIF nor Paragon could usefully encode the desired confidentiality policy.

JIF's policy model fundamentally cannot express the concept of confidentiality dependent upon a dynamic \textit{set} of users. A class may be parametrised by a fixed number of principals, and runtime principals and labels may be used under some circumstances, but the type system is unable to actually encode or enforced the policy required to provide meaningful verification of the confidentiality properties of this application.

Paragon comes closer to encoding the policy; its policy definition language allows for universal quantification over objects, and a parametrised lock may be used to denote attendance status. However, the compiler's type checker is then not able to properly enforce this policy and as a result, Paragon cannot provide the desired security guarantees.

\section{Project Reflection}

Difficulty getting started: conceptual burden, getting set up.

\section{Further Work}

The analysis of the JIF programming language presented in this thesis focused on development using recent versions of JIF and the standard JIF runtime. The JPmail project \cite{jpmailpage} at Pennsylvania State University developed a set of policy tools for JIF which were not thoroughly examined for this comparison. These tools include an Eclipse plugin, JIFclipse, along with tools for supporting a policy store with dynamic look-up of principals. However, these tools were designed for a significantly outdated version of JIF and require the use of a modified JIF runtime, and the project is no longer under active development.

In the literature, there are also other approaches to alleviating some of the limitations of JIF. One such approach is that taken by the RX language \cite{swamy06rx}, which builds upon the Decentralised Label Model but attempts to introduce support for dynamic policy through `policy updates', using both static analysis and runtime checks to reason about the information flows through a program. Though the principles of the RX language have been developed through two papers \cite{hicks05rx} \cite{swamy06rx}, it has not been implemented in practice.

In a 2016 paper \citeauthor{kozyri2016jrif} \cite{kozyri2016jrif} introduce an approach to dynamic information flow policy which aims to address limitations in JIF, based on `Reactive Information Flow (RIF) automata'. Whereas a DLM label as used in JIF encodes a set of principals who may read the data, a RIF label encodes a finite state automaton, with each state associated with a set of principals who may read the data \textit{when the automaton is in that state}. Dynamic policies are represented through the use of transitions in these automata.

The paper \cite{kozyri2016jrif} introduces JRIF, a language based upon JIF which implements RIF automaton-based security typing, and presents example implementations of Battleships, and a calendar application (which is conceptually similar to the Calendar Scheduler case study presented in \ref{sect_cs_csched}). The JRIF language potentially presents a way to resolve many of the issues encountered with JIF's label model through the development of the three case studies in this thesis; however, the JRIF label syntax is substantially more complex even than JIF and so it may not be a panacaea to the programmer burden issues encountered with JIF.


POLICY AGNOSTICISM

Runtime flow checking

LIFTy \cite{polikarpova2016lifty}

Cloud?