\chapter{JIF and Paragon} \label{intro_to_jif_para}

The Java Information Flow (JIF) and Paragon programming languages are both `mostly static' information flow (IF) extentions to the Java language which use type systems to enforce information flow constraints.

As articulated by \citeauthor{broberg2013paragon} in \citetitle{broberg2013paragon} \cite{broberg2013paragon}, JIF may be considered a `second-generation Information Flow language'. Its Decentralised Label Model allowed for more flexible and more useful policies to be expressed than the Mandatory Access Control lattice model that had been central to most prior work \cite{denning1977certification}, and its implementation as an extension of the popular Java language made it comparatively practical to work with.

Under this taxonomy, Paragon is a `third-generation Information Flow language', with policy definition built upon first order logic. This abstraction combined with the Paralock construct broadens the scope of what security requirements can be expressed.

%The Paralock construct which Paragon introduces allow for policies which vary over the lifetime of a running program, something which cannot be represented effectively under JIF's policy model. In addition, Paralocks can model relations between actors of arity zero, one or two, and through the use of binary relations, the Decentralised Label Model can in fact be written within Paragon's policy language. That is, JIF's policy mechanism can be encoded using Paragon's.

\newpage

\section{JIF}

\subsection{Relation to Plain Java}

JFlow, a Java language extension implementing the Decentralised Label Model (DLM) via type checking was first proposed in \citetitle{myers1999jflow}, \cite{myers1999jflow}. It included DLM-based type labels with support for polymorphism and type inference, while integrating with Java's Object-Oriented programming model -- including language features like inheritance and exceptions which introduce potential difficulties for IF checking.

JIF implements a superset of the JFlow functionality, having added a number of additional features over its development \cite{jifwebsite}. Since JIF's 1.0.0 version released in 2003 its design is based on Java 1.4, and so it lacks support for a number of more modern Java features.

In general, working with JIF has a number of differences when compared to Java. Some notable ones include:

\begin{itemize}
	\item JIF places DLM labels on fields, method signatures and potentially local variables
	
	\item The special \mono{declassify} statement (and its integrity equivalent, \mono{endorse}) may be used within the code
	
	\item \textit{All} exceptions are checked in JIF (including runtime exceptions such as \mono{NullPointerException})
	
	\item When running a JIF program, the JIF runtime must be on the classpath
	
	\item Interacting with (non-JIF) Java classes requires writing a JIF interface indicating labels on the class's methods
	
	\item Console I/O using stdin / stdout is performed through Jif's runtime
	
	\item JIF lacks support for the angle bracket generics syntax introduced in more recent versions of Java
\end{itemize}

\subsection{Policy Model}

The \textit{decentralised} nature of the DLM is its primary innovation over previous models. Mandatory Access Control requires that each unit of information -- such as a variable, or method return value in Java -- has a label universally agreed upon by all users of the system. The DLM instead models `principals' in the system (which may represent individual users, groups of users or roles), which do not need to trust each other.

The model uses an \textit{acts-for} relation between principals -- if principal $ p $ acts for principal $ q $, then any action taken by $ p $ is assumed to be authorised by $ q $ \cite{myers2000dlm}.

Confidentiality labels in JIF consist of terms of the form \jiflabel{o->r1,r2}, where \mono{o} is the principal expressing ownership over the policy. When evaluated, these labels produce a \textit{reader set} of principals that the owner believes may read the data -- in this case, \mono{r1} and \mono{r2} and itself, \mono{o}. The reader sets produced form a lattice, and so labels may be combined via the \textit{join} (least upper bound -- ``\mono{;}") and \textit{meet} (greatest lower bound -- ``\mono{meet}") operators, which produce the intersection and union of the constituent labels' reader sets, respectively.

Most commonly, the join operator is used to allow multiple principals to provide differing policies on data. This produces a label of the form \jiflabel{o1->r1,r2; o2->r2,o1,r3}. The join of each policy produces a reader set which is the \textit{intersection} of both -- so in this case, only \mono{r2} and \mono{o1} (or principals which act for either) may read the information. Note that neither \mono{o1} nor \mono{o2} is the `true' owner of the data: each is simply expressing what they believe the policy to be.

In addition to producing new labels via the join and meet operators, there exist a top principal (written \mono{*}), which is a principal for which no other principals act, and a bottom principal (written \mono{\_}), for which all other principals act. A reader set consisting of the top principal allows \textit{nobody} to read the information, and a reader set consisting of the bottom principal allows \textit{anyone} to read the information.

In practice, a label term of the form \jiflabel{Alice->*} indicates that Alice believes that only she should be in the reader set; a label term \jiflabel{Alice->\_} indicates that Alice believes that everyone should be in the reader set.

\subsection{Implicit Flows}

Since information may leak to a lower confidentiality implicitly via flow of control, JIF has a program counter (pc) label which represents the confidentiality status of the current block of code. For instance, within a branch of an \mono{if} statement with a conditional dependent on a high confidentiality value, the pc label will have high confidentiality.

\subsection{Label Annotations}

\begin{minted}{Java}
public String{P->_} myField;

public int{A->*} method{B->*}(String{C->*} param) : {D->*}
\end{minted}

The above shows JIF labels on a field, indicating that field's confidentiality, and a method signature. Local variables may be annotated with labels, but JIF uses type inference to attempt to determine the correct label for local variables automatically.

The annotations on the method signature above have the following effects:

\begin{itemize}
	\item \jiflabel{A->*} is the maximum label of the method's return value
	
	\item \jiflabel{B->*} is the `begin label' -- the required pc label for the method to run
	
	\item \jiflabel{C->*} is the maximum label on \mono{param}
	
	\item \jiflabel{D->*} is the `end label' -- the pc label once the method returns
\end{itemize}

\newpage

\subsection{Declassification}

It is allowable for the label of a value or variable in JIF to change \textit{if} that re-labelling results in a label which is strictly higher confidentiality. Hence, restricting readers or adding an additional policy to a label is always acceptable, as is adding a new reader \mono{r} if there already exists a reader in the policy which \mono{r} acts for.

However, most useful programs must leak some information to lower confidentiality in order to perform useful action. JIF provides the declassification construct in order to enable this.

The following program shows a simple declassification, annotated:

\begin{minted}{Java}
public class TestProgram authority (Alice) <1> {
	
	public static void main{Alice->*}(principal p, String[] args)  <2>
						where authority(Alice), caller(p) {
		declassifyInt();
	}
	
	public static void declassifyInt{Alice->*}() 
						where authority(Alice) <3> {
		int{Alice->*} high;
		int low{Alice->_} low;
		
		low = declassify(high, {Alice->*} to {Alice->_}); <4>
	}

}
\end{minted}

\begin{enumerate}
	
	\item The \mono{authority} clause indicates this class has principal Alice's authority
	
	\item The Main method includes an argument which indicates the principal running the program
	
	\item The \mono{where} clause indicates that this method runs under Alice's authority
	
	\item The actual declassification statement; it declassifies the information in \mono{high} down to \jiflabel{Alice->\_}.
	
\end{enumerate}

\subsection{Integrity Controls}

From version 3.0.0, JIF includes a set of integrity controls in addition to the confidentiality controls discussed here. These controls are beyond the scope of this thesis and so will not be examined in-depth. In brief, the integrity lattice is much like the confidentiality lattice, except rather than being ordered by how high the confidentiality is, integrity labels are ordered by how \textit{trusted} they are, and information cannot flow from untrusted to trusted context.

\subsection{Security Type Polymorphism}

Given all data must be labelled (or have a label determined implicitly via type inference), writing implementations of standard data types presents a challenge -- it is desirable to avoid having to rewrite the \mono{ArrayList} class for every possible security label the elements of the list may have. To deal with this, JIF introduces security type generics. Since JIF's syntax was designed prior to Java's adoption of generics, square brackets are used to denote type parameters (as opposed to angle brackets).

JIF provides two different kinds of generics: \textit{label} generics and \textit{principal} generics.

A class with a label generic, of the form \mono{TestClass[label L]} may be parametrised by any label. The label type parameter may be used anywhere within the class (e.g. as labels on fields, method return values or begin/end labels). Using this, a data type like \mono{ArrayList[Label L]} may be written such that it can be instantiated with any confidentiality label on the elements.

The second kind of generic is the principal generic, of the form \mono{TestClass[principal P]}. The principal type parameter may be used in labels in the class. This allows for classes which have explicit policies, but which are generic to being `owned' by any principal.

% \subsection{Sample ``Hello World" Application}

\section{Paragon}

\subsection{Relation to Plain Java}

Like JIF, Paragon is an extension upon the Java language. Unlike JIF, Paragon includes support for a number of more recent Java features -- most notably, Java generics. Paragon's own generic features, discussed in more detail in \ref{para_generics} below, make use of the standard Java angle brackets syntax and hence can be mixed with Java type parameters.

Like JIF, there are a number of differences between writing a program in Paragon and writing one in plain Java, including the following:

\begin{itemize}
	
	\item Fields, method parameters and potentially local variables are annotated with read policies
	
	\item Locks and policies can be defined through special syntax, and locks can be opened and closed in the code
	
	\item Method signatures may include read and write annotations, as well as lock state annotations
	
	\item As with JIF, all exceptions are checked in Paragon, though it introduces the \mono{notnull} modifier for variables which can prevent the need to catch \mono{NullPointerException}
	
	\item Paragon's runtime must be on the classpath when running the program
	
	\item Interacting with plain Java classes requires writing a Paragon interface
	
\end{itemize}

\subsection{Static Policies}

A policy in Paragon consists of some number of semicolon-separated \textit{clauses}, each of which consists of a \textit{head} and a \textit{body}. A policy \mono{p} with two clauses would be defined using the following syntax:

\begin{minted}{Java}
policy p = {head1: body1 ; head2: body2};
\end{minted}

The head of a clause specifies which \textit{actors} may view information under this policy. Unlike the equivalent `principals' in JIF, actors in Paragon are simply regular Java objects. So a simple static policy allowing \mono{User}s Alice and Bob to read a file could be encoded as follows \cite{broberg2013paragon}:

\begin{minted}{Java}
User alice = new User("Alice");
User bob = new User("Bob");
policy aliceAndBob = {alice: ; bob:};
\end{minted}

Actors in the head of a clause may also be universally quantified over, so in the following, information may flow to any instance of the type \mono{User}:

\begin{minted}{Java}
policy allUsers = {User u:};
\end{minted}

Using this policy definition, a top policy (which disallows all flow) and a bottom policy (which allows all flow) may be encoded:

\begin{minted}{Java}
policy top = {:};
policy bottom = {Object x:};
\end{minted}

These policies form a lattice, and so as with Mandatory Access Control and JIF, they can be combined with least upper bound (join -- \mono{*}) and greatest lower bound (meet -- \mono{+}) operators.

The tools described here suffice for encoding a MAC-style static information flow policy.

\subsection{Policy Annotations}

Values in Paragon are associated with a policy via policy modifiers. Variables, method return types and parameters can have a `read effect' modifier on them, denoted by the \mono{?} symbol, indicating their security policy. For example:

\begin{minted}{Java}
?{Object x:} int x;
?somePolicy String y;
?(policy1 * policy2) float z;
public ?p int method(?q int param1, ?r int param2) { ...
\end{minted}

Read effect modifiers allow the Paragon compiler to analyse the explicit flow of information throughout a program, ensuring that values may only be assigned to variables with appropriate policies. However, another form of modifier, the `write effect' modifier for methods is needed to properly analyse implicit information flows in a program with many methods.

A method's write effect, annotated using the \mono{!} symbol, denotes the lowest confidentiality level at which a method's side effects (such as writing to an output or performing different actions based on a high confidentiality conditional) would be observable. For instance, consider the following:

\begin{minted}{Java}
?high int secret;
?low int notSecret;

!low void setNotSecret(?low int value) {
	notSecret = value;
}
\end{minted}

Then, consider the method definition:

\begin{minted}{Java}
void method() {
	if (secret > 0) {
		setNotSecret(1);
	} else {
		setNotSecret(0);
	}
}
\end{minted}

The (low confidentiality) \mono{notSecret} variable is assigned within a context dependent on the value of the high confidentiality \mono{secret} variable, but the compiler cannot immediately see this, as it occurs inside a method. However, the required \mono{!low} annotation on \mono{setNotSecret} allows the compiler to determine that \mono{setNotSecret} has side effects at a low confidentiality level, and hence that it may not be used within the high conditional -- so with this method the code will not compile.

\subsection{Dynamic Policies with Paralocks}

The primary innovation of Paragon's policy model is the `Flow Lock' or `ParaLock' construct: a way to build time-variant flow policies using a global state. ParaLocks (or more simply, just `locks') in Paragon are boolean values which may be \textit{open} or \textit{closed} at a given point in a program's execution, but which are analysed statically in order to allow Paragon to encode policies that cannot be expressed with a static lattice.

A lock in Paragon in Paragon may be declared only as a field, which is implicitly both \mono{final} and \mono{static}. The lock may then appear in the body of a Paragon policy:

\begin{minted}{Java}
lock myLock;
policy p = {Object x: myLock};
\end{minted}

The \mono{open} and \mono{close} statements may be used to change its state. Dynamic policies (i.e. those with non-empty bodies) are evaluated statically by erasing the locks known to be open. The policy of a given value once open locks are erased is known as its `effective policy'.

\begin{minted}{Java}
?p int x = 5;
// Compile error
?{Object x:} y = x;
open myLock;
// Compiles fine - effective policy erases myLock,
// giving a policy of {Object x:}
?{Object x:} z = x;
close myLock;
\end{minted}

Locks can be used to perform run-time flow checking simply by using them as normal conditionals.

\subsubsection{Locks for Declassification}

Locks can quite succinctly model selective declassification, similar to that performed by JIF, by having a `declassifying' lock which is closed at all times, except during a declassification. The following presents a simple example:

\begin{minted}{Java}
lock myLock;

public ?{Object x:} int declassifyValue(?{Object x: myLock} int x) {
	?{Object x:} result;
	open myLock;
	result = x;
	close myLock;
	return x;
}
\end{minted}

Then, values at level \paralabel{Object x}{myLock} may be declassified via this method.

\subsubsection{Parametrised Locks}

Paragon supports a generalisation over the simple open/closed locks presented above. Locks may be parametrised by actors -- Paragon's syntax supports parametrised locks of arity one and two.

Intuitively, parametrised locks may be thought of as \textit{classes} of simple locks, so a lock \mono{myLock(User)} may be open or closed for any given instance of \mono{User}. Alternatively, parametrised locks can be considered as unary and binary relations over actors: so a 2-ary lock \mono{myLock(User, File)} is a relation such that the lock is open if the relation holds for a \monotuple{User, File} pair.

Once declared, a parametrised lock may be used in the body of a policy.

\begin{minted}{Java}
lock unaryLock(User);
lock binaryLock(User, User);
policy p1 = {User u: unaryLock(u)};
policy p2 = {(User u) User v: binaryLock(u, v)};
\end{minted}

Note that the use of \mono{(User u)} in the head of policy \mono{p2} indicates quantification, in this case existential. In natural language, \mono{p2} states that: ``Information may flow to any User \mono{v} if there exists some \mono{v} such that \mono{binaryLock(u, v)} is open."

Commonly, unary locks may be used to model dynamic \textit{roles} -- where the information that may flow to an actor depends on their current role or status. Binary locks are often used to model \textit{relationships} between actors \cite{broberg2013paragon}.

\subsubsection{Lock Properties}

In order to allow for clearer policy definition and reduce policy-related boilerplate code, Paragon allows for locks to be defined with `lock properties', representing conditions under which a lock is implicitly open. For instance, on a binary lock, the following lock property could be defined:

\begin{minted}{Java}
lock myLock(User, User) {(User a, b) myLock(b, a): myLock(b, a)};
\end{minted}

This states that for users \mono{a} and \mono{b}, \mono{myLock(b, a)} is implicitly open if mono{myLock(b, a)} is open -- when regarded as a binary relation, \mono{myLock} is symmetric.

Many possible lock properties can be defined depending on the program's overall policy, but Paragon provides shorthand modifiers for symmetry, reflexivity and transitivity, allowing for a binary lock defined as:

\begin{minted}{Java}
reflexive symmetric transitive lock myLock(User, User);
\end{minted}

\subsubsection{Lock Annotations}

Paragon's compiler keeps track of the global lock state statically, which requires statically analysing all possible program flows. Under certain circumstances -- especially where lock state changes across many different methods -- the compiler cannot track the state.

In order to aid the compiler's analysis, the programmer can add three kinds of lock annotations as modifiers on method signatures: \mono{+myLock}, \mono{-myLock}, \mono{\textasciitilde myLock}.


The \mono{+} lock annotation may be used on methods which \textit{guarantee} they will open a given lock. The \mono{-} annotation may be used on methods which \textit{may} close a given lock. Finally, the \mono{\textasciitilde} modifier indicates that a method may only be called from a context where the given lock is known to be open.

For instance, consider the following method signature:

\begin{minted}{Java}
public +lock1 -lock2(alice, bob) ~lock3(charles) void method() {
\end{minted}

This method signature indicates the method \textit{always} opens \mono{lock1}, \textit{may} close \mono{lock2} for the actor pair \monotuple{alice, bob}, and may only be called in a context where \mono{lock3} is open for actor \mono{charles}.

One noteworthy limitation in Paragon's lock annotation syntax is that it is not possible to quantify over actors in lock annotations. So, for instance, it is not possible to produce an annotation indicating that a method may close a lock for all actors matching some criteria.

\subsection{Security Type Polymorphism} \label{para_generics}

As with JIF, the modularity and reusability of Paragon code is a concern, since the policy definition is embedded with the implementation. Paragon and JIF take the same approach to resolve this issue, relying on security type polymorphism and type parametrisation to make code more generic, and allowing `interfaces' to be written for interoperability with plain Java code.

\subsubsection{The \mono{policyof} Operator}

Paragon provides the special \mono{policyof} operator to allow for policy-polymorphic variables and methods.

The special policy denoted by \mono{policyof(this)}, which may be used on methods and \mono{final} fields, is equivalent to JIF's special \jiflabel{this} label -- the labelled field or method return value takes on the policy of the overall instance. This allows for simple datatypes which are completely polymorphic with respect to policy, such as the following immutable pair definition:

\begin{minted}{Java}
class Pair {
	public final ?policyof(this) int x;
	public final ?policyof(this) int y;
	
	public Pair(?policyof(this) int x, ?policyof(this) int y) {
		this.x = x;
		this.y = y;
	} 
}
\end{minted}

This class can then be used, and the \mono{x} and \mono{y} fields will take on the policy of the instance:

\begin{minted}{Java}
?{Object x:} Pair lowPair = new Pair(0, 0);
?{:} Pair highPair = new Pair(0, 0);

// Allowed
?{Object x:} int xFromLow = lowPair.x;
// Compile error
?{Object x:} int xFromHigh = highPair.x;
\end{minted}

The \mono{policyof} operator may also be used in method return types to allow methods to be polymorphic in the policies of their arguments: \mono{policyof(param)} is equivalent to using a \jiflabel{param} label in JIF. For example, a simple addition method can be made completely polymorphic in its arguments by joining the policies of its arguments:

\begin{minted}{Java}
static ?(policyof(a) * policyof(b)) int add(int a, int b) {
	return a + b;
}
\end{minted}

\subsubsection{Generics}

Paragon also provides security type generics, for more complex polymorphic classes. Unlike JIF, Paragon supports Java's native generics functionality, and its security type generics simply extend this. Paragon provides \textit{policy} generics and \textit{actor} generics, equivalent to JIF's label and principal generics respectively.

A generic class in Paragon is declared with the following syntax:

\begin{minted}{Java}
public class MyClass<T, policy P, actor A> {
\end{minted}

Here, \mono{T} is a regular Java type parameter, \mono{P} is a policy type parameter and \mono{A} is an actor type parameter. This class could then be instantiated with:

\begin{minted}{Java}
final User alice = new User();
MyClass<String, {Object x:}, alice> instance;
instance = new MyClass<String, {Object x:}, alice>();
\end{minted}

Policy generics are commonly used to give some internal component of an instance a different but polymorphic policy to the instance itself -- for instance, an ArrayList allowing specification of the policy of each element. Actor generics are used to denote ownership, where a class specifies a policy, but instances may `belong' to any actor.

\subsubsection{Java Interoperability}

Paragon provides interoperability with plain Java classes through `Paragon Interfaces'. Essentially, any Java class may be called from a Paragon class by writing its interface in a \mono{.pi} file with the desired Paragon policy annotations attached.

This is similar to JIF's Java interoperability, although unlike JIF, Paragon's compiler does not compile Paragon source files directly to Java bytecode: the output of \mono{parac} is a generated Java source (\mono{.java} file) and a \mono{.pi} Paragon interface.

%\subsection{Sample ``Hello World" Application}