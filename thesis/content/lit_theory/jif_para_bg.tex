\chapter{JIF and Paragon} \label{intro_to_jif_para}

%\section{Overview \& High Level Differences}

The Java Information Flow (JIF) and Paragon programming languages both fall into the category of `mostly static' information flow (IF) languages. Both extend the Java language, and both use type systems to enforce information flow constraints.

%The two languages differ primarily in their policy models. JIF's policy model, the Decentralised Label Model (DLM) \cite{myers2000dlm}, represents a refinement of the `lattice model' of Mandatory Access Control previously used to statically check information flows \cite{denning1977certification}. Like in the lattice model, DLM labels are partially ordered to represent the classification of information, but rather than consisting of some static compartments, DLM labels consist of relationships between interacting `principals'. In addition, unlike the lattice model the DLM explicitly considers selective declassification, which is essential for any practical development of an application.

As articulated by \citeauthor{broberg2013paragon} in \citetitle{broberg2013paragon} \cite{broberg2013paragon}, JIF may be regarded as a `second-generation Information Flow language'. Its Decentralised Label Model allowed for more flexible and more useful policies to be expressed than the straight Mandatory Access Control lattice that had been at the centre of most prior work \cite{denning1977certification}, and its implementation as an extension of the popular Java language made it comparatively practical to work with.

Under this taxonomy, Paragon is a `third-generation Information Flow language'. It discards lattice-based policy definition entirely in favour of policies which may defined through propositional logic. This abstraction, combined with the Paralock construct which allows for policies which model relations and which vary over the lifetime of a running program, broadens the scope of what security requirements can be expressed.

The Paralock construct which Paragon introduces allow for policies which vary over the lifetime of a running program, something which cannot be represented effectively under JIF's policy model. In addition, Paralocks can model relations between actors of arity zero, one or two, and through the use of binary relations, the Decentralised Label Model can in fact be written within Paragon's policy language. That is, JIF's policy mechanism can be encoded using Paragon's.

\newpage

\section{JIF}

\subsection{Relation to Plain Java}

A language implementation of the Decentralised Label Model via type checking was first proposed in \citetitle{myers1999jflow}, \cite{myers1999jflow}. JFlow was a proposed extension to the Java language which would include DLM-based type labels with support for polymorphism and type inference, while integrating with Java's Object-Oriented programming model -- including language features like inheritance and exceptions which introduce potential difficulties for IF checking.

JIF implements a superset of the JFlow functionality, having added a number of additional features over its development \cite{jifwebsite}. Since JIF's 1.0.0 version released in 2003 its design is based on Java 1.4, and so it lacks support for a number of more modern Java features, including generics.

\subsection{Policy Model}

The core innovation of the Decentralised Label Model over previous lattice-based security models is, somewhat unsurprisingly, that it is decentralised. Mandatory access control requires that each unit of information has a label that is universally agreed upon by all users of the system. The DLM instead models `principals' in the system (which may represent individual users, groups of users or roles), which do not need to trust each other.

The model uses an \textit{acts-for} relation between principals -- if principal $ p $ acts for principal $ q $, then any action taken by $ p $ is assumed to be authorised by $ q $ \cite{myers2000dlm}.

A confidentiality term in JIF is then a statement of the form \mono{o->r1,r2}, where \mono{o} is the principal which owns the data, and \mono{r1,r2} is the list of principals that the owner allows to read the data. A \textit{label}, the overall policy on the data, is some combination of terms written in the form \jiflabel{o1->r1,r2; o2->r2,r3}. Both \mono{o1} and \mono{o2} are considered `owners' of the data and so \textit{both} terms must be obeyed -- only \mono{r2} or a principal that can act for \mono{r2} may read data with this label.



\subsection{Integrity Controls}

\subsection{Declassification}

\subsection{Security Type Polymorphism}

\subsection{Sample ``Hello World" Application}

\section{Paragon}

\subsection{Relation to Plain Java}

\subsection{Policy Model}

\subsection{Paralocks}

\subsection{Security Type Polymorphism}

\subsection{Sample ``Hello World" Application}