\chapter{JIF and Paragon} \label{intro_to_jif_para}

The Java Information Flow (JIF) and Paragon programming languages are both `mostly static' information flow (IF) extentions to the Java language which use type systems to enforce information flow constraints.

As articulated by \citeauthor{broberg2013paragon} in \citetitle{broberg2013paragon} \cite{broberg2013paragon}, JIF may be considered a `second-generation Information Flow language'. Its Decentralised Label Model allowed for more flexible and more useful policies to be expressed than the Mandatory Access Control lattice model that had been central to most prior work \cite{denning1977certification}, and its implementation as an extension of the popular Java language made it comparatively practical to work with.

Under this taxonomy, Paragon is a `third-generation Information Flow language', with policy definition built upon first order logic. This abstraction combined with the Paralock construct broadens the scope of what security requirements can be expressed.

%The Paralock construct which Paragon introduces allow for policies which vary over the lifetime of a running program, something which cannot be represented effectively under JIF's policy model. In addition, Paralocks can model relations between actors of arity zero, one or two, and through the use of binary relations, the Decentralised Label Model can in fact be written within Paragon's policy language. That is, JIF's policy mechanism can be encoded using Paragon's.

\newpage

\section{JIF}

\subsection{Relation to Plain Java}

JFlow, a Java language extension implementing the Decentralised Label Model via type checking was first proposed in \citetitle{myers1999jflow}, \cite{myers1999jflow}. It included DLM-based type labels with support for polymorphism and type inference, while integrating with Java's Object-Oriented programming model -- including language features like inheritance and exceptions which introduce potential difficulties for IF checking.

JIF implements a superset of the JFlow functionality, having added a number of additional features over its development \cite{jifwebsite}. Since JIF's 1.0.0 version released in 2003 its design is based on Java 1.4, and so it lacks support for a number of more modern Java features.

In general, working with JIF has a number of differences when compared to Java. Some notable ones include:

\begin{itemize}
	\item JIF places DLM labels on fields, method signatures and potentially local variables
	
	\item The special \mono{declassify} statement (and its integrity equivalent, \mono{endorse}) may be used within the code
	
	\item \textit{All} exceptions are checked in JIF (including runtime exceptions such as \mono{NullPointerException})
	
	\item When running a JIF program, the JIF runtime must be on the classpath
	
	\item Interacting with (non-JIF) Java classes requires writing a JIF interface indicating labels on the class's methods
	
	\item Console I/O using stdin / stdout is performed through Jif's runtime
	
	\item JIF lacks support for the angle bracket generics syntax introduced in more recent versions of Java
\end{itemize}

\subsection{Policy Model}

The \textit{decentralised} nature of the DLM is its primary innovation over previous models. Mandatory Access Control requires that each unit of information has a label universally agreed upon by all users of the system. The DLM instead models `principals' in the system (which may represent individual users, groups of users or roles), which do not need to trust each other.

The model uses an \textit{acts-for} relation between principals -- if principal $ p $ acts for principal $ q $, then any action taken by $ p $ is assumed to be authorised by $ q $ \cite{myers2000dlm}.

Confidentiality labels in JIF are of the form \jiflabel{o->r1,r2}, where \mono{o} is the principal who owns the data, and \mono{r1,r2} is the list of other principals the owner allows to read the data. These terms form a lattice, and so labels may be formed by combining other labels via the \textit{join} (least upper bound -- ``\mono{;}") and \textit{meet} (greatest lower bound -- ``\mono{meet}") operators.

Most commonly, the join operator is used to allow multiple principals to provide differing policies on data, producing a label of the form \jiflabel{o1->r1,r2; o2->r2,o1,r3}. Where two labels are joined, \textit{both} policies apply -- so the effect is that only \mono{o1} and \mono{r2}, or principals acting for either, could access the data, since they appear in both clauses.

\subsection{Implicit Flows}

Since information may leak to a lower confidentiality implicitly via flow of control, JIF has a program counter (pc) label which represents the confidentiality status of the current block of code. For instance, within a branch of an \mono{if} statement with a conditional dependent on a high confidentiality value, the pc label will have high confidentiality.

JIF allows method signatures to specify the following confidentiality labels:

\begin{minted}{Java}
public int{A->*} method{B->*}(String{C->*} param) : {D->*}
\end{minted}

\begin{itemize}
	\item \jiflabel{A->*} is the maximum label of the method's return value
	
	\item \jiflabel{B->*} is the `begin label' -- the required pc label for the method to run
	
	\item \jiflabel{C->*} is the maximum label on \mono{param}
	
	\item \jiflabel{D->*} is the `end label' -- the pc label once the method returns
\end{itemize}

\newpage

\subsection{Declassification}

It is allowable for the label of a value or variable in JIF to change \textit{if} that re-labelling results in a label which is strictly higher confidentiality. Hence, restricting readers or adding an additional policy to a label is always acceptable, as is adding a new reader \mono{r} if there already exists a reader in the policy which \mono{r} acts for.

However, most useful programs must leak some information to lower confidentiality in order to perform useful action. JIF provides the declassification construct in order to enable this.

The following program shows a simple declassification, annotated:

\begin{minted}{Java}
public class TestProgram authority (Alice) <1> {
	
	public static void main{Alice->*}(principal p, String[] args)  <2>
						where authority(Alice), caller(p) {
		declassifyInt();
	}
	
	public static void declassifyInt{Alice->*}() 
						where authority(Alice) <3> {
		int{Alice->*} high;
		int low{Alice->_} low;
		
		low = declassify(high, {Alice->*} to {Alice->_}); <4>
	}

}
\end{minted}

\begin{enumerate}
	
	\item The \mono{authority} clause indicates this class has principal Alice's authority
	
	\item The Main method includes an argument which indicates the principal running the program
	
	\item The \mono{where} clause indicates that this method runs under Alice's authority
	
	\item The actual declassification statement; it declassifies the information in \mono{high} down to \jiflabel{Alice->\_}.
	
\end{enumerate}

\subsection{Integrity Controls}

From version 3.0.0, JIF includes a set of integrity controls in addition to the confidentiality controls discussed here. These controls are beyond the scope of this thesis and so will not be examined in-depth. In brief, the integrity lattice is much like the confidentiality lattice, except rather than being ordered by how high the confidentiality is, integrity labels are ordered by how \textit{trusted} they are, and information cannot flow from untrusted to trusted context.

\subsection{Security Type Polymorphism}

Given all data must be labelled (or have a label determined implicitly via type inference), writing implementations of standard data types presents a challenge -- it is desirable to avoid having to rewrite the \mono{ArrayList} class for every possible security label the elements of the list may have. To deal with this, JIF introduces security type generics. Since JIF's syntax was designed prior to Java's adoption of generics, square brackets are used to denote type parameters (as opposed to angle brackets).

JIF provides two different kinds of generics: \textit{label} generics and \textit{principal} generics.

A class with a label generic, of the form \mono{TestClass[label L]} may be parametrised by any label. The label type parameter may be used anywhere within the class (e.g. as labels on fields, method return values or begin/end labels). Using this, a data type like \mono{ArrayList[Label L]} may be written such that it can be instantiated with any confidentiality label on the elements.

The second kind of generic is the principal generic, of the form \mono{TestClass[principal P]}. The principal type parameter may be used in labels in the class. This allows for classes which have explicit policies, but which are generic to being `owned' by any principal.

% \subsection{Sample ``Hello World" Application}

\section{Paragon}

\subsection{Relation to Plain Java}

Like JIF, Paragon is an extension upon the Java language. Unlike JIF, Paragon includes support for a number of more recent Java features -- most notably, Java generics. Paragon's own generic features, discussed in more detail in \ref{para_generics} below, make use of the standard Java angle brackets syntax and hence can be mixed with Java type parameters.

Like JIF, there are a number of differences between writing a program in Paragon and writing one in plain Java, including the following:

\begin{itemize}
	
	\item Fields, method parameters and potentially local variables are annotated with read policies
	
	\item Locks and policies can be defined through special syntax, and locks can be opened and closed in the code
	
	\item Method signatures may include read and write annotations, as well as lock state annotations
	
	\item As with JIF, all exceptions are checked in Paragon, though it introduces the \mono{notnull} modifier for variables which can prevent the need to catch \mono{NullPointerException}
	
	\item Paragon's runtime must be on the classpath when running the program
	
	\item Interacting with plain Java classes requires writing a Paragon interface
	
\end{itemize}

\subsection{Static Policies}

A policy in Paragon consists of some number of semicolon-separated \textit{clauses}, each of which consists of a \textit{head} and a \textit{body}. A policy \mono{p} with two clauses would be defined using the following syntax:

\begin{minted}{Java}
policy p = {head1: body1 ; head2: body2};
\end{minted}

The head of a clause specifies which \textit{actors} may view information under this policy. Unlike the equivalent `principals' in JIF, actors in Paragon are simply regular Java objects. So a simple static policy allowing \mono{User}s Alice and Bob to read a file could be encoded as follows \cite{broberg2013paragon}:

\begin{minted}{Java}
User alice = new User("Alice");
User bob = new User("Bob");
policy aliceAndBob = {alice: ; bob:};
\end{minted}

Actors in the head of a clause may also be universally quantified over, so in the following, information may flow to any instance of the type \mono{User}:

\begin{minted}{Java}
policy allUsers = {User u:};
\end{minted}

Using this policy definition, a top policy (which disallows all flow) and a bottom policy (which allows all flow) may be encoded:

\begin{minted}{Java}
policy top = {:};
policy bottom = {Object x:};
\end{minted}

These policies form a lattice, and so as with Mandatory Access Control and JIF, they can be combined with least upper bound (join -- \mono{+}) and greatest lower bound (meet -- \mono{*}) operators.

The tools described here suffice for encoding a MAC-style static information flow policy.

\subsection{Policy Annotations}

READ EFFECTS

WRITE EFFECTS + IMPLICIT FLOWS

\subsection{Dynamic Policies with Paralocks}

The primary innovation of Paragon's policy model is the `Flow Lock' or `ParaLock' construct: a way to build time-variant flow policies using a global state. ParaLocks (or more simply, just `locks') in Paragon are boolean values which may be \textit{open} or \textit{closed} at a given point in a program's execution, but which are analysed statically in order to allow Paragon to encode policies that cannot be expressed with a static lattice.

A lock in Paragon in Paragon may be declared only as a field, which is implicitly both \mono{final} and \mono{static}. The lock may then appear in the body of a Paragon policy:

\begin{minted}{Java}
lock myLock;
policy p = {Object x: myLock};
\end{minted}

The \mono{open} and \mono{close} statements may be used to change its state. Dynamic policies (i.e. those with non-empty bodies) are evaluated statically by erasing the locks known to be open. The policy of a given value once open locks are erased is known as its `effective policy'.

\begin{minted}{Java}
?p int x = 5;
// Compile error
?{Object x:} y = x;
open myLock;
// Compiles fine - effective policy erases myLock,
// giving a policy of {Object x:}
?{Object x:} z = x;
close myLock;
\end{minted}

Locks can be used to perform run-time flow checking simply by using them as normal conditionals

DECLASSIFICATION

TIMED RELEASE

LOCK PROPERTIES

LOCK ANNOTATIONS

\subsection{Security Type Polymorphism} \label{para_generics}

\subsection{Sample ``Hello World" Application}