Question: how to connect NativePrincipal (like currentUser())
	  with PrincipalHierarchy?

	  1) It would make sense to establish a declassFor from 
	  TestPrincipal bono
	  to NativePrincipal phicks, for example.

	  All data within the program lives in the manufactured PrincipalHierarchy
	  while the output gets funnelled through the FileSystem PrincipalHierarchy
	  
	  2) Another option is to overload NativePrincipal and add a 
	     method addDelegatesTo(principal p)

	  3) Actually, by indicating that one of the principals trusts the user, 
	     that should be enough to allow the user to print stuff out that the
	     principal would want to have printed out

	  4) we could establish trust so long as user can provide principal's private key.
	  
Question: how should the PrincipalHierarchy be labeled?
	  1) it could be labeled with Manager where Manager is the top dog everyone trusts
	  2) if it is labeled with manager then either	    
	     a) all principal delegations must be made through the hierarchy
	     OR
***	     b) the principals will need to be declassified when released from the PH
	     	they can maintain their own label so that only they can add 
		to their delegations
	     OR
	     c) perhaps the principals don't need to maintain their own labels, 
	     	because one can only add to the delegations if there is sufficient 
		authority, which can be routed through a Closure.  Then they should 
		still be declassified back to {}.

Note: see diagram paper/figures/EmailClientBasic.graffle
      Mail is encrypted from server and labeled with server-label
      to declassify from server-label to client-label, Email is decrypted and released 
      	 only if the X-Jif-label is readable by the Email client
      "labelCheck" is the declassifier which does this
      labelCheck is trusted by the server-label to declassify its data
      alternatively, labelCheck could make an authorization
      labelCheck checks with the PrincipalHierarchy to make the checks

      the I/O and file system are under a different principal than the rest.
      In order to access the I/O and file system, the client-principal needs to
      	 delegate to the I/O and file system.  Alternatively, I suppose there could
	 be a declassifier between the client-principal and the user-principal.

Readers Note:
	Finally figured something out about reader lists
	look at working/PrincipalHierarchy_reader_example.jif
	the important thing is to recognize that {user:mcdaniel} means that 
	user guarantees only he and mcdaniel can read this channel.
	So, if bono trusts user, then {bono:mcdaniel} data can be printed on
	that channel.  If the channel is {user:riverboat} and mcdaniel doesn't trust
	riverboat, then {bono:mcdaniel} can't be printed on a {user:riverboat} channel.

Errors Note:
Getting an error such as:

CastToJavaExt_c.java (compiler generated):51:

seems to indicate that something has become stale.  The best way to handle it is
to delete the .class files and recompile from scratch.

Got this error:
/usr/local/jif-2.0.1/bin/jifc -sigcp /usr/local/jif-2.0.1/sig-classes:/Users/phicks/cs/research/jif/jif2/sig-classes principals/PrincipalStore.jif -explain
CastToJavaExt_c.java (compiler generated):51: quasiquote(principals.PrincipalWrapper.jif$cast$principals_PrincipalWrapper([jif{amb}.lang{amb}.LabelUtil{amb}.privacyPolicyLabel(this.jif$principals_PrincipalStore_P, new jif{amb}.lang{amb}.PrincipalSet{amb}(...)), obj]E)):1:
    Field "PrincipalWrapper" not found in type "jif.util.List".
CastToJavaExt_c.java (compiler generated):51: quasiquote(principals.PrincipalWrapper.jif$cast$principals_PrincipalWrapper([jif{amb}.lang{amb}.LabelUtil{amb}.privacyPolicyLabel(this.jif$principals_PrincipalStore_P, new jif{amb}.lang{amb}.PrincipalSet{amb}(...)), obj]E)):1:
    Field "PrincipalWrapper" not found in type "jif.util.List".
2 errors.

and needed to rebuild my classes and all the Jif classes to fix it.


----1/13/06----
NOTE:
It is troubling that a principal can be null and the actsfor check succeeds.
This can be very misleading.

Rearranged PrincipalHierarchy into PrincipalStore
This is essentially a dictionary which stores names and Principals
It is parameterized by a Principal, mgr, which should be a ManagerPrincipal
Only a process with mgr's authority can add a principal to the Store.  It is presumed
that the Store would be set up in advance, or only if a user can enter the correct
password and act as the manager to add principals.  These principals then can be
used to label anything, really.  They are intended for use with Emails in which an owner
can be indicated in a field, then looked up in the Store and applied to the object that
is being created.

Why should the parameter be a ManagerPrincipal?

The ManagerPrincipal allows the DeclassPrincipalClosure always to receive
authorization.  This means that principals can be declassified to an arbitrary
label.  This is necessary, because all principals stored in the PrincipalStore
are raised to the security level of the manager.  In order to be useful they will have to
be declassified.  This is done in PrincipalStore.getPrincipal(String name,label lb) in 
which the label can be an arbitrary security label.  This method has side-effects at the level
of lb, which means that it can be used in a sensitive context so long as the declassification
of the Principal doesn't go below lb.

More NOTES about the different classes:

AddDelClosureL[P,L](principal{L} del)
  this makes it so that (del actsfor P) and has side-effects of L
  Note that L must be less than the label on del and L must be greater than {P:} ({P:} <= L)

DeclassPrincipalClosure[P,L]{lb} = new DeclassPrincipalClosure[P,L](prin);
  this declassifies prin{P:} to {*lb} and has side-effects of L (could be <top>? at least 
  it's presumably lb).  This is convoluted, but because the return type has to be {this}
  it's not clear how to fix it with the current limitations on principals.

When doing authorizations and returning a value, the authPrf has to be at the level of the 
thing that will be granting the permission and the level of the value that is being returned.
Thus, if we're declassifying to {}, then the authPrf needs to be {}.  If we're declassifying
to {lb} (as in the case in PrincipalStore.getPrincipal) then {authPrf} needs to be less than
the level of {lb}.

One way to think about this is that if I'm going to release info to you, then YOU need to
provide the authPrf.  You can't just feed me my own authPrf (which you can't even read).

retval = (Principal)principalUtil.authorize(P,authPrf,dpc,lb).invoke();
