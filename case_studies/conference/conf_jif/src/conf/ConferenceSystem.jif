package conf;

import jif.util.HashMap;

/**
 * A system to handle the submission, approval and session allocation of papers to a conference
 */
public class ConferenceSystem[principal O] authority(O) {
    
    // private static final policy bottom = {Object x :};

    // public static ?bottom lock allocationsVisible;

    // public static final policy ifAllocationsVisible = {Object x : allocationsVisible; Organiser o :};

    // The conference chair / organiser, who can see all information even before it is public
    public final Organiser{O->_} organiser;

    public final label AL = new label {O->*};

    private boolean{O->_} allocationsVisible;

    private int{O->_} numSubmissions;
    private Paper[AL]{O->_}[]{O->_} submissions;

    // The allocation of accepted papers to allocations
    private HashMap[AL, AL] allocations;

    public ConferenceSystem() {
        organiser = new Organiser("TheOrganiser");

        submissions = new Paper[AL][5];
        numSubmissions = 0;

        allocations = new HashMap[AL, AL]();
    }

    /**
     * Upgrade a paper's policy such that its authors may only be viewed under the double-blind conditions
     */
    // private Paper[???][] upgradePaper(Paper[???] paper) {
    //     Author[] paperAuthors = paper.getAuthors();
    //     Author[] upgradedAuthors = new Author[paperAuthors.length];

    //     // Need to upgrade the policy of all authors from bottom -> ifAllocationsVisible
    //     for (int i = 0; i < paperAuthors.length; ++i) {
    //         Author u = paperAuthors[i];
    //         upgradedAuthors[i] = u;
    //     }

    //     Paper[???] upgraded = new Paper[???](paper.getTitle(), paper.getAbstract(), upgradedAuthors);

    //     return upgraded;
    // }

    public void handleSubmission{O->_}(Paper[AL]{O->_} paper) {
        // Can't submit after the conference sessions are already allocated
        try {
            if (!allocationsVisible) {
                submissions[numSubmissions] = paper; //upgradePaper(paper);
                numSubmissions++;

                // Resize array if required
                if (numSubmissions >= submissions.length) {
                    Paper[AL][]{O->_} newSubmissions = new Paper[numSubmissions * 2];
                    for (int i = 0; i < submissions.length; ++i) {
                        newSubmissions[i] = submissions[i];
                    }
                    submissions = newSubmissions;
                }
            }
        } catch (ArrayIndexOutOfBoundsException ex) {
            
        } catch (NegativeArraySizeException ex) {
            
        } catch (NullPointerException ex) {

        }
    }

    public Paper[AL][]{O->_} getSubmissions() {
        try {
            return this.submissions.clone();
        } catch (NullPointerException ex) {
            return new Paper[AL][2];
        }
    }

    public int{O->_} getSessionNumber{O->_}(Paper[AL]{O->_} paper) where authority(O) {
        // try {
        //     if (allocationsVisible) {
        //         JifInteger[AL] sNo = (JifInteger[AL])allocations.get(paper);
        //         int{AL} sNoVal = sNo.intValue();
        //         return -1;
        //     } else {
        //         return -1;
        //     }
        // } catch (NullPointerException ex) {
        //     return -1;
        // } catch (ClassCastException ex) {
        //     return -1;
        // }

        if (allocationsVisible) {
            // int{O->_} result;
            try {
                JifInteger[AL] sNo = (JifInteger[AL])allocations.get(paper);
                int{O->*} toDowngrade = sNo.intValue();
                int{O->_} result = declassify(toDowngrade, {*AL} to {O->_});
                return result;
            } catch (NullPointerException ex) {

            } catch (ClassCastException ex) {

            }

            return -1;
        } else {
            return -1;
        }
    }

    public void performAllocations{}() {
        // Arbitrary allocation - just give each paper a unique session number
        try {
            for (int i = 0; i < numSubmissions; ++i) {
                allocations.put(submissions[i], new JifInteger[AL](i));
            }
        } catch (ArrayIndexOutOfBoundsException ex) {

        } catch (NullPointerException ex) {

        }
    }

    public void setAllocationsVisible{}() {
        allocationsVisible = true;
        // open allocationsVisible;
    }

}
