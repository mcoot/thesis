package scheduler;

// import scheduler.User;
// import scheduler.WeekDay;

/**
 * An entry in the calendar
 *
 * It is assumed that all engagements start/end on the hour
 */
public final class CalendarEntry {

    public final CalendarEntry self = (CalendarEntry)this;

    public static final policy allUsers = {User u : };

    // Binary lock associating a user with a calendar entry
    // I.e. the lock is open if the user is attending that engagement
    public lock isAttending(User, CalendarEntry);

    // Policy stating that:
    // Information may flow to any user u providing that u is attending this entry
    public static final policy attendeesOnly = {
        User u : isAttending(u, self)
    };
    // The day on which the engagement is held
    private final ?allUsers WeekDay day;
    // The hour on which the engagement starts
    private final ?allUsers int startHour;
    // The hour on which the engagement ends
    private final ?allUsers int endHour;
    // The title of the engagement
    private final ?attendeesOnly String title;
    // The engagement description
    private final ?attendeesOnly String description;

    // The list of users who are attending the engagement
    private final ?allUsers User[] attendees;

    /**
     * Construct a new calendar entry
     *
     * @param day the day the engagement is on
     * @param startHour the hour the engagement starts
     * @param endHour the hour the engagement ends
     * @param title the title of the engagement
     * @param description the engagement description
     * @param attendees the attendees of the engagement
     * @throws CalendarException if the times are invalid
     */
    public !allUsers CalendarEntry(?allUsers WeekDay day,?allUsers int startHour,?allUsers int endHour,
                         ?allUsers String title, ?allUsers String description, ?allUsers User[]<allUsers> attendees)
            throws !allUsers CalendarException {

        // Check that the engagement is valid
        if (!areTimesValid(startHour, endHour)) {
            throw new CalendarException(
                    String.format("Engagement %s (%d - %d) is not valid", title, startHour, endHour));
        }
        this.day = day;
        this.startHour = startHour;
        this.endHour = endHour;
        if (title == null) {
            throw new CalendarException("Title may not be null");
        }
        this.title = title;
        if (description == null) {
            throw new CalendarException("Description may not be null");
        }
        this.description = description;
        if (attendees == null) {
            throw new CalendarException("Attendees may not be null");
        }
        this.attendees = new User[attendees.length];
        for (int i = 0; i < attendees.length; ++i) {
            this.attendees[i] = attendees[i];
        }

        setAttendanceLocks();
    }

    /**
     * Construct a new calendar entry with only one attendee
     *
     * @param day the day the engagement is on
     * @param startHour the hour the engagement starts
     * @param endHour the hour the engagement ends
     * @param title the title of the engagement
     * @param description the engagement description
     * @param attendee the user attending the engagement
     */
    // public CalendarEntry(WeekDay day, int startHour, int endHour,
    //                      String title, String description, User attendee)
    //         throws CalendarException {
    //     ArrayList singletonAttendees = new ArrayList();
    //     singletonAttendees.add(attendee);
    //     this(day, startHour, endHour, title, description, singletonAttendees);
    // }

    /**
     * Open the policy locks for the attendees of this event
     */
    private void setAttendanceLocks() {
        
        for (int i = 0; i < this.attendees.length; ++i) {
            User curAttendee = attendees[i];
            open isAttending(curAttendee, self);
        }
    }

    /**
     * Check whether the given times are possible for an engagement
     *
     * @param startHour the start time
     * @param endHour the end time
     * @return true iff the times are valid for an engagement
     */
    private boolean areTimesValid(?allUsers int startHour, ?allUsers int endHour) {
        // Must be valid hours - cannot start after 11pm or end after midnight
        if (startHour < 0 || startHour > 23) return false;
        if (endHour < 0 || endHour > 24) return false;
        // Start must be earlier than end
        if (startHour >= endHour) return false;
        return true;
    }

    public ?allUsers int getStartHour() {
        return startHour;
    }

    public ?allUsers int getEndHour() {
        return endHour;
    }

    public ?allUsers int getDuration() {
        return endHour - startHour;
    }

    public ?attendeesOnly String getTitle() {
        return title;
    }

    public ?attendeesOnly String getDescription() {
        return description;
    }

    public ?allUsers User[] getAttendees() {
        return attendees;
    }

    /**
     * Check whether this entry overlaps with another entry
     *
     * If an entry ends at the same time the other starts, it is assumed they do not overlap
     *
     * @param entry the entry to check against
     * @return true iff the entries overlap in time
     */
    public ?allUsers boolean overlapsWith(?allUsers CalendarEntry entry) {
        try {
            // Check they are on the same day
            if (!day.equals(entry.day)) return false;
            // If one entry's start is within the other entry, they overlap
            return ((startHour >= entry.startHour && startHour < entry.endHour)
                    || (entry.startHour >= startHour && entry.startHour < endHour));
        } catch (NullPointerException ex) {
            return false;
        }
        
    }

    public ?(attendeesOnly*policyof(o)) boolean equals(Object o) {
        // if (!(o instanceof CalendarEntry)) return false;
        CalendarEntry other = null;
        try {
            other = (CalendarEntry)o;
        } catch (ClassCastException ex) {
            return false;
        }

        try {
            return day.equals(other.day)
                && other.startHour == startHour && other.endHour == endHour
                && title.equals(other.title) && description.equals(other.description);
               // && attendees.equals(other.attendees);
        } catch (NullPointerException ex) {
            return false;
        }
    }

    public ?attendeesOnly int hashCode() {
        int result = 19;
        result = 29 * result + day.hashCode();
        result = 29 * result + startHour;
        result = 29 * result + endHour;
        result = 29 * result + title.hashCode();
        result = 29 * result + description.hashCode();
        // result = 29 * result + attendees.hashCode();

        return result;
    }

    // public ?allUsers !allUsers String printOut(?allUsers User u) {
    //     if (isAttending(u, self)) {
    //         String sep = "\n";
    //         String format = "Calendar Entry: " + sep + "\tTitle: %s" + sep + "\tDescription: %s"
    //                 + sep + "\tTime/Day: %d - %d, %s" + sep + "\tAttendees: %s";

    //         String s = "";
    //         String commaSep = "";
    //         for (int i = 0; i < attendees.length; ++i) {
    //             User u = attendees[i];
    //             s += commaSep;
    //             s += u.toString();
    //             commaSep = ", ";
    //         }
    //         ?attendeesOnly String ret = String.format(format, title, description, startHour, endHour, day.toString(), s);
    //         return ret;
    //     } else {
    //         return "";
    //     }
    // }

    public ?attendeesOnly String toString() {
        String sep = "\n";
        String format = "Calendar Entry: " + sep + "\tTitle: %s" + sep + "\tDescription: %s"
                + sep + "\tTime/Day: %d - %d, %s" + sep + "\tAttendees: %s";

        String s = "";
        String commaSep = "";
        for (int i = 0; i < attendees.length; ++i) {
            User u = attendees[i];
            s += commaSep;
            s += u.toString();
            commaSep = ", ";
        }

        return String.format(format, title, description, startHour, endHour, day.toString(), s);
    }

}
