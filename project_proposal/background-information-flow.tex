\subsection{Information Flow}

\subsubsection{Overview and Rationale}

Information Flow-based security focuses on confidentiality, as opposed to its integrity or availability. This is in contrast to Access Control mechanisms, which take an approach based on limiting which operations a user or program may perform --- controlling confidentiality but also the integrity of a system. Access Control allows the program to assert certain guarantees around what a process can \textit{do}, but it does not directly represent the problem at the heart of confidentiality: how to control when and how confidential data moves through a system.

Information Flow mechanisms, on the other hand, specifically model how confidential data moves through a system, and can therefore provide robust guarantees about that movement. It does not specifically address integrity at all, though there is a relationship between integrity and confidentiality --- they can be seen as duals, where confidentiality concerns the `leakage' of data from the private system to a public output, and integrity concerns the flow of `contaminated' public data to the private system \cite{biba1977integrity} \cite{clarkson2010confintegrity}.

Because Access Control mechanisms (such as Java's stack inspection-based SecurityManager, or Access Control List solutions) focus on modelling access to a system, they can ensure `tainted' data does not reach secure elements, thereby providing integrity, but they cannot prevent a user, program or call stack (in the case of SecurityManager) which \textit{has} privileged access from disseminating confidential data in an unauthorised way.

The purpose of Information Flow security is to model the flow of information through a program and prevent data from moving from a high confidentiality state to a low confidentiality state. These are usually modelled by applying Bell and La Padula's Lattice Model \cite{bell1976lattice} of `Mandatory Access Control' to the state of a program and its variables. Either statically (at compile-time) or dynamically (at run-time) the Lattice Model sensitivity labels applied to data are used to enforce a `high water mark' \cite{ausanka2001accesscontrol} approach to the clearance a program has --- that is, a program flow which interacts with high sensitivity data can never `write down' to a lower confidentiality level.

\subsubsection{Principles}

	\paragraph{Lattice Model}
	
	The Lattice Model developed by Bell and La Padula for the US Department of Defense \cite{bell1976lattice} defines a system of `mandatory access controls' which explicitly specify what flows of information are allowed and disallowed. This may be used in conjunction with more traditional discretionary Access Control-based methods, such as Access Control Lists \cite{sandhu1993lattice}, where a user must have access both via the discretionary policy (which may be modified by users with appropriate permissions) and the mandatory policy (which may not be modified by users, even if they have clearance).
	
	The Lattice Model defines `security labels' (or \textit{classifications}) on data objects, as well as on subjects (which may be users or programs), where the label is the \textit{clearance} they are operating under \cite{denning1976lattice}. In a military context (as originally envisioned by the model), labels may range from `Unclassified' through to `Top Secret', with some number of classification between. A user with a maximum clearance of `Top Secret' may run a program at the `Unclassified' level, in which case the \textit{subject} (the program) will only have `Unclassified' clearance \cite{sandhu1993lattice}.
	
	
	
	\cite{denning1976lattice}
	
	\cite{sandhu1994access}
	
	\paragraph{Implicit Flows}
	
	\paragraph{Run-Time Information Flow Checking}

	\paragraph{Security Typing}
	
	\paragraph{Transitive / Intransitive Flows}

\subsubsection{Security Model Implementations}

	\paragraph{Java Information Flow (JIF)}
	
	\paragraph{Paragon}