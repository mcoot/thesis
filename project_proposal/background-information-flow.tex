\subsection{Information Flow}

\subsubsection{Overview and Rationale}

Information Flow-based security focuses on confidentiality, as opposed to its integrity or availability. This is in contrast to Access Control mechanisms, which take an approach based on limiting which operations a user or program may perform --- controlling confidentiality but also the integrity of a system. Access Control allows the program to assert certain guarantees around what a process can \textit{do}, but it does not directly represent the problem at the heart of confidentiality: how to control when and how confidential data moves through a system.

Information Flow mechanisms, on the other hand, specifically model how confidential data moves through a system, and can therefore provide robust guarantees about that movement. It does not specifically address integrity at all, though there is a relationship between integrity and confidentiality --- they can be seen as duals, where confidentiality concerns the `leakage' of data from the private system to a public output, and integrity concerns the flow of `contaminated' public data to the private system \cite{biba1977integrity} \cite{clarkson2010confintegrity}.

Because Access Control mechanisms (such as Java's stack inspection-based SecurityManager, or Access Control List solutions) focus on modelling access to a system, they can ensure `tainted' data does not reach secure elements, thereby providing integrity, but they cannot prevent a user, program or call stack (in the case of SecurityManager) which \textit{has} privileged access from disseminating confidential data in an unauthorised way (REFERENCE).

The purpose of Information Flow security is to model the flow of information through a program and prevent data from moving from a high confidentiality state to a low confidentiality state. These are usually modelled by applying Bell and La Padula's Lattice Model \cite{bell1976lattice} of `Mandatory Access Control' to the state of a program and its variables. Either statically (at compile-time) or dynamically (at run-time) the Lattice Model sensitivity labels applied to data are used to prevent execution paths in which high confidentiality data would flow to a low confidentiality state.

\subsubsection{Principles}

	\paragraph{Lattice Model}
	
	The Lattice Model developed by Bell and La Padula for the US Department of Defense \cite{bell1976lattice} defines a system of `mandatory access controls' which explicitly specify what flows of information are allowed and disallowed. This may be used in conjunction with more traditional discretionary Access Control-based methods, such as Access Control Lists \cite{sandhu1993lattice}, where a user must have access both via the discretionary policy (which may be modified by users with appropriate permissions) and the mandatory policy (which may not be modified by users, even if they have clearance).
	
	The Lattice Model defines `security labels' (or \textit{classifications}) on data objects, as well as on subjects (which may be users or programs), where the label is the \textit{clearance} they are operating under \cite{denning1976lattice}. In a military context (as originally envisioned by the model), labels may range from `Unclassified' through to `Top Secret', with some number of classification between. A user with a maximum clearance of `Top Secret' may run a program at the `Unclassified' level, in which case the \textit{subject} (the program) will only have `Unclassified' clearance \cite{sandhu1993lattice}.
	
	Formally, the Bell - LaPadula model defines, given a set of security classes $ S $, and a `dominates' relation ($ \ge $) \cite{sandhu1993lattice} which defines a partial ordering on the labels, such that data of security class $ B $ can only flow to any class $ A $ such that $ A \ge B $. This may equivalently be defined, as by Denning \cite{denning1976lattice} as a `flow' relation $ \rightarrow $ which operates in another direction, such that data of class $ B $ may only flow to any class $ A $ such that $ B \rightarrow A $.
	
	This model is applied to the access control problem concerning subjects (users/programs) and objects (data) via two properties \cite{bell1973lattice}:
	
	\begin{description}
		\item[Simple Security Property -- `No Read Up'] A subject with clearance $ C_s $ may only access a data object with classification $ C_o $ if $ C_s \ge C_o $ ($ C_o \rightarrow C_s $)
		\item[* Property -- `No Write Down'] A subject with clearance $ C_s $ may only modify a data object with classification $ C_o $ if $ C_o \ge C_s $ ($ C_s \rightarrow C_o $)
	\end{description}
	
	Because of the Simple Security Property, a user with low clearance cannot access data at a high clearance, and because of the * Property, a user with high clearance cannot modify low clearance data, preventing them from `declassifying' high clearance information by gaining simply, for example, copying sensitive information into a file marked at a low classification.
	
	Together, these rules enforce control over information flows: information may only flow from low to high classification, never from high to low. This requires a `high water mark' \cite{jones1975highwatermark} policy, wherein during a program's execution, its security level is monotonically non-decreasing: the clearance it is operating at may rise, but never decrease during execution. For the purposes of Information Flow security, this policy is usually not applied to the linear execution of a program --- it is sufficient to show that no possible execution paths release data to a lower confidentiality level, as both static and dynamic applications of language-based Information Flow security do \cite{sabelfeld2003if}.
	
	\cite{denning1976lattice}
	
	\cite{sandhu1994access}
	
	\paragraph{Implicit Flows}
	
	Since language-based Information Flow security examines all possible execution paths of a program, it must consider not only what high classification information is revealed by the execution path that occurs, but also by the paths that \textit{don't} occur --- that is, information which is revealed through `implicit' information flows \cite{sabelfeld2003if}.
	
	Denning \& Denning \cite{denning1977if} define an explicit flow $ x \rightarrow y$ as a flow where the operations performed are independent of the value of $ x $ --- such as an assignment statement $ y := x $. They then define an implicit flow $ x \rightarrow y$ as an arbitrary flow from some $ z \rightarrow y $, but where the execution depends upon the value of $ x $, such as where execution branches based on $ x $, as in the following example: $ y := 1; \keyword{if} x = 0 \keyword{then} y := 0 \keyword{else} \text{skip}\;$ \cite{denning1977if}.
	
	In the example above, in the case where the \textbf{then} branch executes, an attacker has gained knowledge of the value of $ x $ even though it was not explicitly modified -- because after the execution occurs, $ y = 0 $, and therefore $ x = 0 $. However, even if the \textbf{else} branch occurs, the attacker still gains information; since $ y = 1 $, the \textbf{then} branch wasn't taken and therefore $ x \ne 0 $.
	
	In order to be considered `secure' from an Information Flow perspective, the program must not reveal information about the state of $ x $ under \textit{any} execution path, whether through implicit or explicit flows.
	
	\paragraph{Covert Channels}
	
	Consider a program which -- by the definition given in the Implicit Flows section -- is secure. Specifically, consider the following: 
	
	\begin{algorithmic}
		\State $ y := 1 $
		\If {$ x = 0 $}
			\For{$ i := 1 $ \textbf{to} $ 1000000 $}
				\State skip
			\EndFor
		\Else
			\State skip
		\EndIf
	\end{algorithmic}
	
	This program does not include any flows, explicit or otherwise, from $ x \rightarrow y $. There is neither any explicit assignment based on $ x $, nor does the control flow dependent on $ x $ produce any observable output in the state of $ y $. However, an adversary able to run this program can still determine information about the value of $ x $ based on the length of time that the program takes to execute. If $ x = 0 $, then the program will run the for loop and take significantly longer to execute than if $ x \ne 0 $ and the else branch is taken.
	
	This is an example of a covert channel attack, and specifically a \textit{timing} channel attack.
	
	\paragraph{Selective Declassification}
	
	
	
	\paragraph{Run-Time Information Flow Checking}
	
	\cite{austin2009dynamicif}
	
	\paragraph{Security Typing}
	
	\paragraph{Transitive / Intransitive Flows}

\subsubsection{Security Model Implementations}

	\paragraph{Java Information Flow (JIF)}
	
	\paragraph{Paragon}